<!doctype html>
<html>
    <head>
        <style>
            .selected {
                stroke-dasharray: 5, 5;
                stroke: red;
                stroke-width: 3;
            }
            .greyed {
                stroke: lightgrey;
            }
            html {
                margin: 0;
                width: 100%;
                height: 100%;
            }
            body {
                margin: 0;
                padding: 0;
                width: 100%;
                min-height: 100%;
            }
            svg {
                position: absolute;
                left: 0;
                top: 0;
                display: block;
                overflow: visible;
                padding: 0;
                width: 100%;
                min-height: 100%;
            }

            svg text {
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }
            svg text::selection {
                background: none;
            }
            form {
                background-color: white;
                position: relative;
                margin: 0;
                padding: 1em;
                top: 1em;
                width: 20%;
                /* overflow: hidden; */
            }
            input {
                width: 80%;
            }

            label {
            }
        </style>
    </head>
    <body>
        <svg id="my-svg"></svg>
        <form id="search-bar">
            <label for="search-text">Search:</label>
            <input type="text" id="search-text" name="search-text" />
        </form>

        <script src="export_graph_data.js"></script>
        <script>
            // mock data for tests
            // var sourceData = {
            //     nodes: [
            //         { id: "one", type: "one", x: 150, y: 150 },
            //         { id: "two", type: "two", x: 450, y: 450 },
            //         { id: "three", type: "two", x: 450, y: 150 },
            //         { id: "four", type: "two", x: 150, y: 450 },
            //     ],
            //     edges: [
            //         {
            //             source_node_id: "one",
            //             source_node_type: "one",
            //             target_node_id: "two",
            //             target_node_type: "two",
            //             type: "relation 1-2",
            //         },
            //         {
            //             source_node_id: "one",
            //             source_node_type: "one",
            //             target_node_id: "three",
            //             target_node_type: "two",
            //             type: "relation 1-3",
            //         },
            //         {
            //             source_node_id: "two",
            //             source_node_type: "two",
            //             target_node_id: "four",
            //             target_node_type: "two",
            //             type: "relation 2-4",
            //         },
            //     ],
            // };

            // TOOD: make node-edge browser to see displayed nodes as a list

            // TODO: scale movements by current scaling factor
            // TODO: display scrolls bars to show where camera is or where is the active area (ocupied by nodes)

            var graph_data = {
                nodes: [],
                edges: [],
            };

            var _full_node_index = {};
            for (n of sourceData.nodes) {
                // for quick search
                let k = `${n.id}: ${n.type}`;
                _full_node_index[k] = n;
            }

            document.addEventListener("DOMContentLoaded", function () {
                //const svg = document.querySelector("svg")
                const svg = document.getElementById("my-svg");
                const searchText = document.getElementById("search-text");
                const searchBar = document.getElementById("search-bar");
                // create nodes

                let randInt = (min, max) => {
                    return Math.floor(min + Math.random() * (max - min));
                };

                let create_node = (node, x, y) => {
                    let name = `${node.id}: ${node.type}`;
                    var g = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "g",
                    );
                    var rect = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "rect",
                    );
                    var text = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "text",
                    );
                    g.appendChild(rect);
                    g.appendChild(text);
                    svg.appendChild(g);

                    text.setAttribute("x", x);
                    text.setAttribute("y", y);
                    text.setAttribute("dominant-baseline", "middle");
                    text.setAttribute("text-anchor", "middle");
                    text.setAttribute("fill", "black");
                    text.textContent = name;

                    let bb = text.getBBox();
                    let width = bb.width + 20;
                    let height = bb.height + 20;

                    rect.setAttribute("x", x - width / 2);
                    rect.setAttribute("y", y - height / 2);

                    rect.setAttribute("width", width);
                    rect.setAttribute("height", height);

                    rect.setAttribute("fill", "white");
                    rect.setAttribute("stroke", "black");
                    rect.setAttribute("stroke-width", 2);
                    rect.setAttribute("rx", 15);
                    return g;
                };

                let create_edge = (edge, x1, y1, x2, y2) => {
                    let name = edge.type;
                    var g = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "g",
                    );
                    var line = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "line",
                    );

                    g.appendChild(line);
                    svg.appendChild(g);

                    line.setAttribute("x1", x1);
                    line.setAttribute("y1", y1);
                    line.setAttribute("x2", x2);
                    line.setAttribute("y2", y2);
                    line.setAttribute("stroke", "purple");
                    line.setAttribute("stroke-width", 2);

                    return g;
                };

                let create_edge_label = (edge, x1, y1, x2, y2) => {
                    let name = edge.type;

                    var g = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "g",
                    );

                    var rect = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "rect",
                    );
                    var text = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "text",
                    );

                    g.appendChild(rect);
                    g.appendChild(text);
                    svg.appendChild(g);

                    let x = (parseFloat(x1) + parseFloat(x2)) / 2;
                    let y = (parseFloat(y1) + parseFloat(y2)) / 2;

                    text.setAttribute("x", x);
                    text.setAttribute("y", y);
                    text.setAttribute("dominant-baseline", "middle");
                    text.setAttribute("text-anchor", "middle");
                    text.setAttribute("fill", "red");
                    text.textContent = name;

                    let width = text.getBBox().width + 20;
                    let height = text.getBBox().height + 20;

                    rect.setAttribute("x", x - width / 2);
                    rect.setAttribute("y", y - height / 2);
                    rect.setAttribute("height", height);
                    rect.setAttribute("width", width);
                    rect.setAttribute("fill", "white");
                    rect.setAttribute("stroke", "white");

                    return g;
                };

                let move_inline = (fixed, move, change) => {
                    // change > 0 - move closer
                    let len = Math.sqrt(
                        Math.pow(fixed.x - move.x, 2) +
                            Math.pow(fixed.y - move.y, 2),
                    );
                    let d = Math.abs(len - change);
                    let k = d / len;

                    let dx = k * move.x + (1 - k) * fixed.x;
                    let dy = k * move.y + (1 - k) * fixed.y;

                    move.x += dx;
                    move.y += dy;
                };

                let findOverlapingRects = (nodes) => {
                    let res = [];
                    // TODO: add margins
                    for (n1 of nodes) {
                        let bb1 = n1.g.children[0].getBBox();

                        // TODO: optimize to search only nearby nodes
                        for (n2 of nodes) {
                            if (n1 == n2) {
                                continue;
                            }
                            let bb2 = n2.g.children[0].getBBox();
                            let intersectX =
                                Math.min(bb1.x + bb1.width, bb2.x + bb2.width) -
                                Math.max(bb1.x, bb2.x);
                            let intersectY =
                                Math.min(
                                    bb1.y + bb1.height,
                                    bb2.y + bb2.height,
                                ) - Math.max(bb1.y, bb2.y);
                            if (intersectX > 0 && intersectY > 0) {
                                res.push([n1, n2]);
                            }
                        }
                    }
                    return res;
                };

                let getMidPoint = (e) => {
                    let bb = e.getBBox();
                    return {
                        x: bb.x + bb.width / 2,
                        y: bb.y + bb.height / 2,
                    };
                };

                let update_edges = (node, x, y) => {
                    let bb = node.getBBox();

                    for (e of node.parentElement.n.in_edges) {
                        // update line
                        e.g.children[0].setAttribute(
                            "x2",
                            bb.x + x + bb.width / 2,
                        );
                        e.g.children[0].setAttribute(
                            "y2",
                            bb.y + y + bb.height / 2,
                        );

                        let m = getMidPoint(e.g.children[0]);

                        // update white rect for label background
                        e.lg.children[0].setAttribute(
                            "x",
                            m.x - e.lg.children[0].getBBox().width / 2,
                        );
                        e.lg.children[0].setAttribute(
                            "y",
                            m.y - e.lg.children[0].getBBox().height / 2,
                        );

                        // update label text
                        e.lg.children[1].setAttribute("x", m.x);
                        e.lg.children[1].setAttribute("y", m.y);
                    }

                    for (e of node.parentElement.n.out_edges) {
                        e.g.children[0].setAttribute(
                            "x1",
                            bb.x + x + bb.width / 2,
                        );
                        e.g.children[0].setAttribute(
                            "y1",
                            bb.y + y + bb.height / 2,
                        );

                        let m = getMidPoint(e.g.children[0]);

                        e.lg.children[0].setAttribute(
                            "x",
                            m.x - e.lg.children[0].getBBox().width / 2,
                        );
                        e.lg.children[0].setAttribute(
                            "y",
                            m.y - e.lg.children[0].getBBox().height / 2,
                        );

                        e.lg.children[1].setAttribute("x", m.x);
                        e.lg.children[1].setAttribute("y", m.y);
                    }
                };

                // ============================================================

                let createAll = () => {
                    console.log("Total nodes: ", graph_data.nodes.length);
                    console.log("Total edges: ", graph_data.edges.length);

                    var node_index = {};
                    // index nodes and init positions
                    for (n of graph_data.nodes) {
                        let k = `${n.id}: ${n.type}`;
                        node_index[k] = n;

                        // n.x = randInt(-2000, 2000);
                        // n.y = randInt(-2000, 2000);
                        n.in_edges = [];
                        n.out_edges = [];
                    }

                    // link edges with nodes
                    for (e of graph_data.edges) {
                        let src_key = `${e.source_node_id}: ${e.source_node_type}`;
                        let tgt_key = `${e.target_node_id}: ${e.target_node_type}`;
                        e.src_node = node_index[src_key];
                        e.target_node = node_index[tgt_key];
                    }

                    // draw edge lines first - to draw them behind nodes
                    for (e of graph_data.edges) {
                        if (e.src_node && e.target_node) {
                            e.g = create_edge(
                                e,
                                e.src_node.x,
                                e.src_node.y,
                                e.target_node.x,
                                e.target_node.y,
                            );
                            e.g.e = e;
                            e.src_node.out_edges.push(e);
                            e.target_node.in_edges.push(e);
                        }
                    }
                    // draw edge labels on top of lines
                    for (e of graph_data.edges) {
                        if (e.src_node && e.target_node) {
                            e.lg = create_edge_label(
                                e,
                                e.src_node.x,
                                e.src_node.y,
                                e.target_node.x,
                                e.target_node.y,
                            );
                        }
                    }

                    // draw nodes last on top of everything else
                    for (n of graph_data.nodes) {
                        // TODO: n.x, n.y - are centers of node rects, not top left corner
                        n.g = create_node(n, n.x, n.y);
                        n.g.n = n;
                    }
                };

                // init
                for (n of sourceData.nodes) {
                    graph_data.nodes.push({
                        id: n.id,
                        type: n.type,
                        x: n.x,
                        y: n.y,
                    });
                }
                for (e of sourceData.edges) {
                    graph_data.edges.push({
                        source_node_id: e.source_node_id,
                        source_node_type: e.source_node_type,
                        target_node_id: e.target_node_id,
                        target_node_type: e.target_node_type,
                        type: e.type,
                    });
                }
                createAll();

                // ============================================================

                let selectedElement = null;

                let mousedown = (e) => {
                    var target = e.target;
                    if (selectedElement) {
                        selectedElement.classList.remove("selected");
                    }
                    if (target.tagName.toLowerCase() == "svg") {
                        return;
                    }
                    if (target.tagName !== "g") {
                        target = target.parentElement;
                    }
                    if (!target.hasOwnProperty("n")) {
                        // check if we are moving node
                        return;
                    }
                    // hide all nodes
                    for (n of graph_data.nodes) {
                        for (child of n.g.children) {
                            child.classList.add("greyed");
                        }
                    }
                    // hide all edges
                    for (edge of graph_data.edges) {
                        for (child of edge.g.children) {
                            child.classList.add("greyed");
                        }
                    }

                    // reenable selected node
                    for (child of target.children) {
                        child.classList.remove("greyed");
                    }

                    selectedElement = target.children[0];
                    selectedElement.classList.add("selected");
                    // console.log(selectedElement.parentElement.n);

                    // reenable connected edges and nodes
                    for (edge of selectedElement.parentElement.n.out_edges) {
                        for (child of edge.g.children) {
                            child.classList.remove("greyed");
                        }
                        for (child of edge.target_node.g.children) {
                            child.classList.remove("greyed");
                        }
                    }
                    for (edge of selectedElement.parentElement.n.in_edges) {
                        for (child of edge.g.children) {
                            child.classList.remove("greyed");
                        }
                        for (child of edge.src_node.g.children) {
                            child.classList.remove("greyed");
                        }
                    }

                    // get mousedown info
                    const startX = e.clientX;
                    const startY = e.clientY;
                    const match = selectedElement.style.transform.match(
                        /translate\((-?\d+)px,\s*(-?\d+)px\)/,
                    );

                    // and we are going to handle mousemove event
                    let mousemoveHandler = (e) => {
                        const dx = e.clientX - startX;
                        const dy = e.clientY - startY;
                        let x = dx;
                        let y = dy;
                        if (match) {
                            x += Number(match[1]);
                            y += Number(match[2]);
                        }
                        for (child of selectedElement.parentElement.children) {
                            child.style.transform = `translate(${x}px, ${y}px)`;
                        }

                        // console.log("Upd edges: ", selectedElement, x, y);
                        update_edges(selectedElement, x, y);
                    };

                    const mouseupHandler = () => {
                        if (selectedElement) {
                            selectedElement.classList.remove("selected");
                            selectedElement = null;
                        }
                        // hide all nodes
                        for (n of graph_data.nodes) {
                            for (child of n.g.children) {
                                child.classList.remove("greyed");
                            }
                        }
                        // unhide all edges
                        for (edge of graph_data.edges) {
                            for (child of edge.g.children) {
                                child.classList.remove("greyed");
                            }
                        }

                        document.removeEventListener(
                            "mousemove",
                            mousemoveHandler,
                        );
                        document.removeEventListener("mouseup", mouseupHandler);

                        document.removeEventListener(
                            "touchmove",
                            mousemoveHandler,
                        );
                        document.removeEventListener(
                            "touchend",
                            mouseupHandler,
                        );
                    };

                    document.addEventListener("mousemove", mousemoveHandler);
                    document.addEventListener("mouseup", mouseupHandler);

                    // window.addEventListener("touchmove", mousemoveHandler);
                    // window.addEventListener("touchend", mouseupHandler);
                };

                svg.addEventListener("mousedown", mousedown);
                // svg.addEventListener("touchstart", mousedown);

                window.addEventListener(
                    "wheel",
                    (e) => {
                        e.preventDefault();
                        const match = svg.style.transform.match(
                            // /translate\((-?\d+)px,\s*(-?\d+)px\)/,
                            /scale\((-?\d+(\.\d+)?),\s*(-?\d+(\.\d+)?)\)\s*translate\((-?\d+(\.\d+)?)px,\s*(-?\d+(\.\d+)?)px\)/,
                        );

                        // console.log("Match", match);

                        var x = 0;
                        var y = 0;
                        var sx = 1.0;

                        if (match) {
                            sx = Number(match[1]);
                            x = Number(match[5]);
                            y = Number(match[7]);
                        }

                        // console.log("Parsed transform: ", x, y, sx);
                        // console.log(e.wheelDelta);
                        // console.log(e.deltaX, e.deltaY);

                        if (e.ctrlKey) {
                            // zoom
                            if (e.wheelDelta > 0) {
                                sx *= 1.05;
                            } else {
                                sx *= 0.95;
                            }
                            // console.log("Scaling", sx);
                        } else {
                            // translate
                            x -= e.deltaX;
                            y -= e.deltaY;
                            // console.log("translating", x, y);
                        }
                        svg.style.transform = `scale(${sx}, ${sx}) translate(${x}px, ${y}px)`;
                    },
                    { passive: false },
                );

                let close = (term, name) => {
                    if (!term.length) {
                        return true;
                    }
                    return (
                        name
                            .trim()
                            .toLowerCase()
                            .indexOf(term.trim().toLowerCase()) !== -1
                    );
                };

                document.addEventListener(
                    "keydown",
                    function (event) {
                        if (event.key === "Enter") {
                            event.preventDefault();
                            console.log("Searching:", searchText.value);

                            console.log(graph_data.nodes);
                            for (n of graph_data.nodes) {
                                n.g.remove();
                            }
                            graph_data.nodes = [];

                            // filter
                            console.log(graph_data.edges);
                            for (e of graph_data.edges) {
                                e.g.remove();
                                e.lg.remove();
                            }
                            graph_data.edges = [];
                            let node_list = {};
                            for (e of sourceData.edges) {
                                if (
                                    close(searchText.value, e.source_node_id) ||
                                    close(
                                        searchText.value,
                                        e.source_node_type,
                                    ) ||
                                    close(searchText.value, e.target_node_id) ||
                                    close(
                                        searchText.value,
                                        e.target_node_type,
                                    ) ||
                                    close(searchText.value, e.type)
                                ) {
                                    graph_data.edges.push({
                                        source_node_id: e.source_node_id,
                                        source_node_type: e.source_node_type,
                                        target_node_id: e.target_node_id,
                                        target_node_type: e.target_node_type,
                                        type: e.type,
                                    });

                                    let _src = `${e.source_node_id}: ${e.source_node_type}`;
                                    node_list[_src] = _full_node_index[_src];
                                    let _dst = `${e.target_node_id}: ${e.target_node_type}`;
                                    node_list[_dst] = _full_node_index[_dst];
                                }
                            }
                            for (n of sourceData.nodes) {
                                if (
                                    close(searchText.value, n.id) ||
                                    close(searchText.value, n.type)
                                ) {
                                    let k = `${n.id}: ${n.type}`;
                                    node_list[k] = n;
                                }
                            }

                            // add all affected nodes
                            for (k in node_list) {
                                let n = node_list[k];
                                graph_data.nodes.push({
                                    id: n.id,
                                    type: n.type,
                                    x: n.x,
                                    y: n.y,
                                });
                            }

                            createAll();

                            // alert(ele.value);
                        }
                    },
                    { passive: false },
                );
            });
        </script>
    </body>
</html>
